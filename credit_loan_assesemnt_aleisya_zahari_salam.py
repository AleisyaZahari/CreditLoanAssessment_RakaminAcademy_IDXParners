# -*- coding: utf-8 -*-
"""Credit Loan Assesemnt_Aleisya Zahari Salam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ptSuTDMvt3GSVqRFtptxxo6hjMQ6CVq2

#Download Data
"""

# download dataset
!gdown 1qobQaTzyxYtMHZVtI57p77Cogeksksi-

# download dictionary dataset
!gdown 1UoUQ1bO15SW27x3FPPBGR29EY-vJnKmE

"""#Import Library"""

import numpy as np
import pandas as pd

import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns

import math
import scipy.stats as stats
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
from sklearn.metrics import classification_report, confusion_matrix

from sklearn.svm import LinearSVC
from sklearn.calibration import CalibratedClassifierCV
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier

from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV

"""# Read Dataset"""

df = pd.read_csv('/content/loan_data_2007_2014.csv')

"""## Data Description"""

dict = pd.read_excel("LCDataDictionary.xlsx", sheet_name="LoanStats")
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.max_colwidth', None)
dict

"""# Data Understanding"""

df.info()

"""* There is unnecessary column that needed to be deleted
* There is missing value that needed to handle
* Several column that doesnt match the content, such as date

# Data Cleansing

## Handling Missing value
"""

missing_counts = df.isnull().sum()


total_rows = len(df)
missing_fraction = missing_counts / total_rows


plt.figure(figsize=(12, 5))
missing_fraction.plot(kind='bar', color='skyblue')
plt.title('Fraction of Missing Values per Column')
plt.xlabel('Columns')
plt.ylabel('Fraction of Missing Values')
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

missing_values_per_column = df.isna().sum().sort_values(ascending = False)

max_missing_values = missing_values_per_column.max()

percentage_missing_values = (missing_values_per_column / max_missing_values) * 100

print("Persentase jumlah missing value dari total keseluruhan data:")
print(percentage_missing_values)
print(percentage_missing_values.index.tolist())

"""Remove columns that have missing values exceeding 80%, except for the `last_pymnt_d` column, which will be retained for feature engineering purposes."""

df1 = df.drop(columns = ['inq_last_12m', 'total_bal_il', 'dti_joint', 'verification_status_joint', 'annual_inc_joint', 'open_acc_6m', 'open_il_6m', 'open_il_12m', 'open_il_24m', 'mths_since_rcnt_il', 'il_util', 'open_rv_24m', 'total_cu_tl', 'inq_fi', 'max_bal_bc', 'all_util', 'open_rv_12m', 'mths_since_last_record', 'mths_since_last_major_derog', 'desc', 'mths_since_last_delinq'])

# For Numerical columns
# replace missing value with "Median"

for col in df1.select_dtypes(exclude = 'object'):
    df1[col] = df[col].fillna(df1[col].median())
df1.isnull().sum()

# For Categorical columns
# replace missing value with "Mode"

for col in df1.select_dtypes(include = 'object'):
    df1[col] = df1[col].fillna(df1[col].mode().iloc[0])
df1.isnull().sum()

"""## Check duplicates"""

df1.duplicated().sum()

"""There is 0 column that has duplicate column

## Delete Unnecessary Column

Delete unnecessary column such as `0` that indicates index
"""

df1 = df1.drop(columns = ['Unnamed: 0'])

"""Removing columns acting as identifiers due to an excess of unique values and others that might impede computational efficiency due to categorical data."""

df1 = df1.drop(columns = ['id', 'member_id', 'url','title','addr_state','zip_code','policy_code','application_type','emp_title'])

df1.head()

"""# Feature Engineering

## Change data type for date
"""

df1['earliest_cr_line'] = pd.to_datetime(df1['earliest_cr_line'], format = '%b-%y')
df1['last_credit_pull_d'] = pd.to_datetime(df1['last_credit_pull_d'], format = '%b-%y')
df1['last_pymnt_d'] = pd.to_datetime(df1['last_pymnt_d'], format = '%b-%y')
df1['issue_d'] = pd.to_datetime(df1['issue_d'], format = '%b-%y')
df1['next_pymnt_d'] = pd.to_datetime(df1['next_pymnt_d'], format = '%b-%y')

df1[['earliest_cr_line','last_credit_pull_d','last_pymnt_d','issue_d','next_pymnt_d']].head()

"""## Add New Features

Adding New Features :

1.  Column `pymnt_time` = the number of month between `next_pymnt_d` and `last_pymnt_d`

2. Column `credit_duration_year` = the number of year between `earliest_cr_line` and `last_credit_pull_d`
"""

def diff_month(a, b):
    return (a.year - b.year) * 12 + a.month - b.month
def diff_year(a, b):
    return (a.year - b.year)

df1['pymnt_time'] = df1.apply(lambda x: diff_month(x.next_pymnt_d, x.last_pymnt_d), axis=1)
df1['credit_duration_year'] = df1.apply(lambda x: diff_year(x.last_credit_pull_d, x.earliest_cr_line), axis=1)

df1.head()

df1[df1['pymnt_time']<0][['next_pymnt_d','last_pymnt_d','pymnt_time']]

df1[df1['credit_duration_year']<0][['earliest_cr_line','last_credit_pull_d','credit_duration_year']]

"""
* Assuming the customer doesn't have a bill to make a payment, the negative value in column `pymnt_time` will be subtituted with 0 and the cause of negative value is assumed due false input
* There is some data that make no sense in feature `earliest_cr_line` and assumed because of false input, therefore resulting negative value in `credit_duration_year`"""

df1.loc[df1['pymnt_time'] < 0,'pymnt_time'] = 0
df1.loc[df1['credit_duration_year'] < 0,'credit_duration_year'] = df1['credit_duration_year'].max()

"""Remove date type columns that have been extracted and any others that have no utility."""

df1.drop(columns=['earliest_cr_line', 'issue_d','next_pymnt_d','last_pymnt_d','last_credit_pull_d'], inplace = True)

"""## Change feature `term`"""

df1.head()

df1['term'].value_counts()

"""There is two unique values in feature `term`.

In further analysis, the `term` column consisting of '36 months' and '60 months' will be transformed into '36' and '60' only.
"""

df1['term'] = df['term'].apply(lambda term: int(term[0:3]))

df1['term'].value_counts()

"""## Check Target Value (`loan_status`)"""

df1['loan_status'].value_counts()

value_counts = df1["loan_status"].value_counts().sort_values(ascending=False)

percentage = value_counts / value_counts.sum()
percentage = percentage.apply(lambda x: "{:.2%}".format(x))

sorted_df = df.loc[df['loan_status'].isin(value_counts.index)]

plt.figure(figsize=(10, 5))
plt.title('Loan Status of All Customer')
sns.countplot(y="loan_status", data=sorted_df, palette='Spectral', order=value_counts.index)
plt.show()

print(percentage)

"""* Between 9 unique value in `loan_status`, `Current`, `Fully Paid`, and `In Grace Period` are defined as good loan.
* Meanwhile, bad loans will be defined as other than the mentioned good loans.
* For the model, the feature will be devided into two group namely 'good loan' that will be represents 1, and 'bad loan' with 0
"""

good = ['Current', 'Fully Paid', 'In Grace Period']
df1['loan_status'] = np.where(df1['loan_status'].isin(good), 1, 0)

df1['loan_status'].value_counts()

churn_rate = df1['loan_status'].value_counts()
explode = (0.05, 0)
text_props = {'color': 'gray', 'weight': 'bold'}

plt.figure(figsize=(7, 5))
plt.pie(churn_rate, labels=['Good Loan', 'Bad Loan'], autopct='%1.1f%%', startangle=90, explode = explode, colors = [ '#64CCC5', '#132043'], textprops=text_props)
plt.axis('equal')
plt.title('Comparison of good loan and bad loan', fontweight='bold', pad=20)
plt.show()

"""# Exploratory Data Analysis"""

df1.head()

df1.tail()

"""## Correlation

### Between Numerical
"""

nums = df1.select_dtypes(include = np.number).columns.tolist()
print(nums)

# between numerical
plt.figure(figsize=(24,24))
df1_num = df1[nums]
sns.heatmap(df1_num.corr(),annot=True,fmt='.3f')

"""Observation :
* Several features are founds to be highly correlated with each other that may caused the model to be unstable.
* Further action is to remove features  that have correlation more than 0.8
"""

corr_matrix = df1_num.corr().abs()
upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))
high_multicor = [column for column in upper.columns if any(upper[column] > 0.8)]

print(high_multicor)

df1 = df1.drop(columns = high_multicor)

df1.head()

"""### Biserial correlation

between continuous and binary (target)
"""

numerical_columns = df1.select_dtypes(include = np.number).columns.tolist()#
numerical_columns

numerical_columns = ['loan_amnt',
 'term',
 'int_rate',
 'annual_inc',
 'dti',
 'delinq_2yrs',
 'inq_last_6mths',
 'open_acc',
 'pub_rec',
 'revol_bal',
 'revol_util',
 'total_acc',
 'out_prncp',
 'total_pymnt',
 'total_rec_int',
 'total_rec_late_fee',
 'recoveries',
 'last_pymnt_amnt',
 'collections_12_mths_ex_med',
 'acc_now_delinq',
 'tot_coll_amt',
 'tot_cur_bal',
 'total_rev_hi_lim',
 'pymnt_time',
 'credit_duration_year']

# Assuming 'numerical_columns' is a list of your numerical columns and 'binary_target' is your binary target column

#['num_col1', 'num_col2', 'num_col3']  # Replace with your numerical columns
binary_target = 'loan_status'  # Replace with your binary target column

correlations = {}  # Dictionary to store correlations

for col in numerical_columns:
    point_biserial_corr, p_value = stats.pointbiserialr(df1[col], df1[binary_target])
    correlations[col] = point_biserial_corr

# Display correlations
for col, corr in correlations.items():
    print(f"Point Biserial Correlation between {col} and {binary_target}: {corr}")

binary_target = 'loan_status'

correlations = {}  # Dictionary to store correlations

for col in numerical_columns:
    point_biserial_corr, p_value = stats.pointbiserialr(df1[col], df1[binary_target])
    correlations[col] = point_biserial_corr

# Display correlations and create visualization
correlation_values = list(correlations.values())
correlation_columns = list(correlations.keys())

print("Point Biserial Correlations:")
for col, corr in correlations.items():
    print(f"Point Biserial Correlation between {col} and {binary_target}: {corr}")

# Create a bar plot for visualization
plt.figure(figsize=(8, 6))
sns.barplot(x=correlation_values, y=correlation_columns, palette='viridis')
plt.xlabel('Point Biserial Correlation')
plt.ylabel('Numerical Columns')
plt.title('Point Biserial Correlation between Numerical Columns and Binary Target')
plt.show()

sorted_correlations = sorted(correlations.items(), key=lambda x: x[1], reverse=True)
sorted_columns = [x[0] for x in sorted_correlations]
sorted_values = [x[1] for x in sorted_correlations]

# Create a bar plot for visualization
plt.figure(figsize=(8, 6))
sns.barplot(x=sorted_values, y=sorted_columns, palette='viridis')
plt.xlabel('Point Biserial Correlation')
plt.ylabel('Numerical Columns')
plt.title('Point Biserial Correlation between Numerical Columns and Binary Target (Descending Order)')
plt.show()

"""* Biserial is used between categorical binary (target) and numerical continuous.

* Several features has little correlation to target, but the deleted one only continuous data and not discrete.

* There is features that has smaller correlation than other, such as `revol_bar`. Remove the feature
"""

df1 = df1.drop(columns = 'revol_bal')

df1.head()

df1.tail()

"""### Between Categorical

#### Check correlation to target
"""

cats = df1.select_dtypes(include=['object']).columns.tolist()
cats

cats1 = ['grade',
 'sub_grade',
 'emp_length',
 'home_ownership',
 'verification_status',
 'pymnt_plan',
 'purpose',
 'initial_list_status']

from scipy.stats import chi2_contingency

chi2_array, p_array = [], []
for column in cats1:

    crosstab = pd.crosstab(df[column], df['loan_status'])
    chi2, p, dof, expected = chi2_contingency(crosstab)
    chi2_array.append(chi2)
    p_array.append(p)

df_chi = pd.DataFrame({
    'Variable': cats1,
    'Chi-square': chi2_array,
    'p-value': p_array
})
df_chi.sort_values(by='Chi-square', ascending=False)

"""In summary, these results suggest that all the examined categorical variables are strongly associated with the 'loan_status'. The smaller p-values strongly support the rejection of the null hypothesis, indicating significant relationships between these variables.

#### Check correlation between features
"""

import pandas as pd
import numpy as np
import seaborn as sns
from scipy.stats import chi2_contingency


categorical_columns = ['grade', 'sub_grade', 'emp_length', 'home_ownership', 'verification_status', 'loan_status', 'pymnt_plan', 'purpose', 'initial_list_status']

# Calculate Cramér's V for pairwise associations
def cramers_v(x, y):
    confusion_matrix = pd.crosstab(x, y)
    chi2 = chi2_contingency(confusion_matrix)[0]
    n = confusion_matrix.sum().sum()
    phi2 = chi2 / n
    r, k = confusion_matrix.shape
    phi2corr = max(0, phi2 - ((k - 1) * (r - 1)) / (n - 1))
    rcorr = r - ((r - 1) ** 2) / (n - 1)
    kcorr = k - ((k - 1) ** 2) / (n - 1)
    return np.sqrt(phi2corr / min((kcorr - 1), (rcorr - 1)))

# Calculate Cramér's V for all pairs of categorical columns
cramer_matrix = pd.DataFrame(index=categorical_columns, columns=categorical_columns)
for i in range(len(categorical_columns)):
    for j in range(len(categorical_columns)):
        cramer_matrix.iloc[i, j] = cramers_v(df[categorical_columns[i]], df[categorical_columns[j]])


cramer_matrix = cramer_matrix.astype(float)


plt.figure(figsize=(10, 8))
sns.heatmap(cramer_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title("Cramér's V Heatmap")
plt.show()

"""* colum `sub_grade` will be deleted due to high correlation to `grade`.

"""

df1 = df1.drop( columns = ['sub_grade'])

"""## Univariate Analysis

### Numerical
"""

df1.select_dtypes(include=np.number).describe().T

nums = df1.select_dtypes(include = np.number).columns.tolist()

features=nums

plt.figure(figsize=(30,25))
for i in range (0, len(features)):
    plt.subplot(10, 4,i+1)
    sns.boxplot(y=df1[features[i]], color='#7752FE', orient='v')
    plt.tight_layout()

features = nums
n= round(len(nums)/3)
plt.rcParams['figure.figsize'] = (10, 18)

for i in range(0, len(features)):

    plt.subplot(n, math.ceil(len(features)/n), i+1)
    sns.histplot(x=df1[features[i]], color='#7752FE')
    plt.xlabel(features[i])
    plt.tight_layout()


plt.show()

plt.figure(figsize=(24,28))

for i in range(0,len(nums)):

    plt.subplot(12,3,i+1)
    sns.kdeplot(x=df1[nums[i]], shade=True,color='#7752FE')
    plt.title(nums[i], fontsize=20)
    plt.xlabel(' ')

    plt.tight_layout()

"""Observations :         
* Most of features are founds to not normaly distributed and has outliers.

### Categorical
"""

df.select_dtypes(include=['object']).describe().T

cats = df1.select_dtypes(include=['object']).columns.tolist()
print(cats)

df1.head()

plt.figure(figsize=(20,20))
count_df = df1.copy()

for col in cats:
    count_df[col] = df1[col].value_counts()

sorted_cats = count_df.sum().sort_values(ascending=False).index

for i in range(0, len(cats)):
    plt.subplot(5, 2, i+1)
    sns.countplot(y=df1[cats[i]], order=df1[cats[i]].value_counts().index, orient='h', palette='magma')
    plt.title(cats[i])
    plt.xlabel(' ')
    plt.tight_layout()

plt.show()

"""Observation :             
* `Grade` is dominated by B
* `emp_length` feature is dominated by emp_length >10 years
* `home_ownership` feature is dominated by mortgage
* `verification_status` feature is dominated by verified
* `purpose feature` is dominated by debt_consolidation
* `initial_list_status` feature is dominated by f
* `pymnt_plan` only show one value that is n, it shows that the feature only have 1 unique value. It will cause problem when training model and is decided to drop the column.
"""

df1 = df1.drop(columns = 'pymnt_plan')

"""## Bivariate Analysis"""

plt.figure(figsize=(20,20))

cats = df1.select_dtypes(include=['object']).columns.tolist()

for i in range(0,len(cats)):
    plt.subplot(5,2,i+1)
    sns.countplot(y=df1[cats[i]], palette='magma', hue=df1['loan_status'])
    plt.title(cats[i])
    plt.xlabel(' ')
    plt.tight_layout()

plt.figure(figsize=(8, 6))
sns.kdeplot(data=df1, x='total_pymnt', palette='magma', hue=df1['loan_status'], vertical = False)

"""# Feature engineering

## Weight Of Evidence and Information value

reference : https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html
"""

df1.info()

nums = df1.select_dtypes(include = np.number).columns.tolist()
cats = df1.select_dtypes(include=['object']).columns.tolist()

df2 = df1.copy()

def woe(df, feature_name):
    feature_name = df.groupby(feature_name).agg(num_observation=('loan_status','count'),good_loan_prob=('loan_status','mean')).reset_index()

    feature_name['grade_proportion'] = feature_name['num_observation']/feature_name['num_observation'].sum()

    feature_name['num_good_loan'] = feature_name['grade_proportion'] * feature_name['num_observation']

    feature_name['num_bad_loan'] = (1-feature_name['grade_proportion']) * feature_name['num_observation']

    feature_name['good_loan_prop'] = feature_name['num_good_loan'] / feature_name['num_good_loan'].sum()

    feature_name['bad_loan_prop'] = feature_name['num_bad_loan'] / feature_name['num_bad_loan'].sum()

    feature_name['weight_of_evidence'] = np.log(feature_name['good_loan_prop'] / feature_name['bad_loan_prop'])

    feature_name = feature_name.sort_values('weight_of_evidence').reset_index(drop=True)

    feature_name['information_value'] = (feature_name['good_loan_prop']-feature_name['bad_loan_prop']) * feature_name['weight_of_evidence']

    feature_name['information_value'] = feature_name['information_value'].sum()

    # Visualize
    feature_name = feature_name.drop(['grade_proportion','num_good_loan','num_bad_loan','good_loan_prop','bad_loan_prop'],axis = 1)
    return feature_name

def dist(feature):
    plt.figure(figsize=(4,2))
    sns.violinplot(df2[feature],color='#7752FE', orient = 'h')
    print('number of unique values :',df2[feature].nunique())
    print('Distribution :')
    print(df2[feature].describe().T)

"""Whether the features are used or not will be based on this information

![image.png](data:image/png;base64,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)

### Categorical
"""

cats.append('term')
print(cats)

for col in cats:
  print(f'\n\n\nWOE features `{col}`')
  display(woe(df2, col))

"""Observation :        
* Of all categorical feature, `verification_status` has low information value. So it is decided to drop the column

## Numerical
"""

print(nums)
del nums[1]
print(nums)
len(nums)

"""### feature `loan_amnt`"""

dist('loan_amnt')

df2['loan_amnt_woe'] = pd.cut(df2['loan_amnt'],10)
woe(df2,'loan_amnt_woe')

"""### feature `int_rate`"""

dist('int_rate')

df2['annual_inc_woe'] = pd.cut(df2['annual_inc'],10)
woe(df2,'annual_inc_woe')

"""### feature `annual_inc`"""

dist('annual_inc')

df2['annual_inc_woe'] = pd.cut(df2['annual_inc'],10)
woe(df2,'annual_inc_woe')

# This column will be grouped

df2['annual_inc_fc'] = np.where((df2['annual_inc']>=0)&(df2['annual_inc']<=200000),'low_income',
                               np.where((df2['annual_inc']>200000)&(df2['annual_inc']<=1500000),'med_income','high_income'))
woe(df2,'annual_inc_fc')

"""Due to high information value, the feature will be dropped

### feature `dti`
"""

dist('dti')

df2['dti_woe'] = pd.cut(df2['dti'],10)
woe(df2,'dti_woe')

"""### feture `delinq_2yrs`"""

dist('delinq_2yrs')

df2['delinq_2yrs_woe'] = pd.cut(df2['delinq_2yrs'],10)
woe(df2,'delinq_2yrs_woe')

"""Due to high information value, the feature will be dropped

### feature `inq_last_6mths`
"""

dist('inq_last_6mths')

df2['inq_last_6mths_woe'] = pd.cut(df2['inq_last_6mths'],10)
woe(df2,'inq_last_6mths_woe')

"""high information value, the feature will be dropped

### feature `open_acc`
"""

dist('open_acc')

df2['open_acc_woe'] = pd.cut(df2['open_acc'],10)
woe(df2,'open_acc_woe')

"""### feature `pub_rec`"""

dist('pub_rec')

df2['pub_rec_woe'] = pd.cut(df2['pub_rec'],10)
woe(df2,'pub_rec_woe')

"""high information value, drop the feature

### feature `revol_util`
"""

dist('revol_util')

df2['revol_util_woe'] = pd.cut(df2['revol_util'],10)
woe(df2,'revol_util_woe')

"""### feature `total_acc`"""

dist('total_acc')

df2['total_acce_woe'] = pd.cut(df2['total_acc'],10)
woe(df2,'total_acc_woe')

"""### feature `out_prncp`"""

dist('out_prncp')

df2['out_prncp_woe'] = pd.cut(df2['out_prncp'],10)
woe(df2,'out_prncp_woe')

"""high information value, drop the feature

### feature `total_pymnt`
"""

dist('total_pymnt')

df2['total_pymnt_woe'] = pd.cut(df2['total_pymnt'],10)
woe(df2,'total_pymnt_woe')

"""### feature `total_rec_int`"""

dist('total_rec_int')

df2['total_rec_int_woe'] = pd.cut(df2['total_rec_int'],10)
woe(df2,'total_rec_int_woe')

"""high information value, drop the feature

### feature `total_rec_late_fee`
"""

dist('total_rec_late_fee')

df2['total_rec_late_fee_woe'] = pd.cut(df2['total_rec_late_fee'],10)
woe(df2,'total_rec_late_fee_woe')

"""high information value, drop the feature

### feature `recoveries`
"""

dist('recoveries')

df2['recoveries_woe'] = pd.cut(df2['recoveries'],10)
woe(df2,'recoveries_woe')

"""high information value, drop the column

### feature `last_pymnt_amnt`
"""

dist('last_pymnt_amnt')

df2['last_pymnt_amnt_woe'] = pd.cut(df2['last_pymnt_amnt'],10)
woe(df2,'last_pymnt_amnt_woe')

# group the column

df2['last_pymnt_amnt_fc'] = np.where((df2['last_pymnt_amnt']>=0)&(df2['last_pymnt_amnt']<=500),0,
                               np.where((df2['last_pymnt_amnt']>500)&(df2['last_pymnt_amnt']<=1000),1,
                               np.where((df2['last_pymnt_amnt']>1000)&(df2['last_pymnt_amnt']<=1500),2,
                                        np.where((df2['last_pymnt_amnt']>1500)&(df2['last_pymnt_amnt']<=3500),3,4))))
woe(df2,'last_pymnt_amnt_fc')

"""### feature `collections_12_mths_ex_med`"""

dist('collections_12_mths_ex_med')

df2['collections_12_mths_ex_med_woe'] = pd.cut(df2['collections_12_mths_ex_med'],10)
woe(df2,'collections_12_mths_ex_med_woe')

"""high information value, drop the column

### feature `acc_now_delinq`
"""

dist('acc_now_delinq')

df2['acc_now_delinq_woe'] = pd.cut(df2['acc_now_delinq'],10)
woe(df2,'acc_now_delinq_woe')

"""high information value, drop the column

### feature `tot_coll_amt`
"""

dist('tot_coll_amt')

df2['tot_coll_amt_woe'] = pd.cut(df2['tot_coll_amt'],10)
woe(df2,'tot_coll_amt_woe')

"""high information value, drop the column

### feature `tot_cur_bal`
"""

dist('tot_cur_bal')

df2['tot_cur_bal_woe'] = pd.cut(df2['tot_cur_bal'],10)
woe(df2,'tot_cur_bal_woe')

"""high information value, drop the column

### feature `total_rev_hi_lim`
"""

dist('total_rev_hi_lim')

df2['total_rev_hi_lim_woe'] = pd.cut(df2['total_rev_hi_lim'],10)
woe(df2,'total_rev_hi_lim_woe')

"""high information value, drop the column

### feature `pymnt_time`
"""

dist('pymnt_time')

df2['pymnt_time_woe'] = pd.cut(df2['pymnt_time'],10)
woe(df2,'pymnt_time_woe')

# this column will be grouped
df2['pymnt_time_fc'] = np.where((df2['pymnt_time']>=0)&(df2['pymnt_time']<=1),0,
                               np.where((df2['pymnt_time']>1)&(df2['pymnt_time']<=6),1,
                               np.where((df2['pymnt_time']>6)&(df2['pymnt_time']<=12),2,3)))

woe(df2,'pymnt_time_fc')

"""### feature `credit_duration_year`"""

dist('credit_duration_year')

df2['credit_duration_year_woe'] = pd.cut(df2['credit_duration_year'],10)
woe(df2,'credit_duration_year_woe')

df2[nums].head()

"""### Conclusion woe and iv"""

# list of feature to be deleted
del_list  = ['verification_status',
             'annual_inc',
             'delinq_2yrs',
             'inq_last_6mths',
             'pub_rec',
             'out_prncp',
             'total_rec_int',
             'total_rec_late_fee',
             'recoveries',
             'collections_12_mths_ex_med',
             'acc_now_delinq',
             'tot_coll_amt',
             'tot_cur_bal',
             'total_rev_hi_lim']

df3 = df1.copy()

df3 = df3.drop(columns = del_list)

df3.head()

print("Shape of data :", df3.shape)
print("Number of rows :", df3.shape[0])
print("Number of columns :", df3.shape[1])

"""there is 17 column available now

## Feature Encoding
"""

df4 = df3.copy()
df4.head()

df4.columns

nums = ['loan_amnt', 'int_rate', 'loan_status',
        'dti', 'open_acc', 'revol_util', 'total_acc',
        'total_pymnt','last_pymnt_amnt', 'pymnt_time',
        'credit_duration_year']
cats = ['term', 'grade', 'emp_length', 'initial_list_status',
       'home_ownership', 'purpose']
#target , 'loan_status'

for cat in cats:
  print(df4[cat].unique())

cats_one_hot = ['term',  'initial_list_status', 'home_ownership', 'purpose']

cats_label_encode = ['grade', 'emp_length']

"""#### Label encoding"""

for cat in cats_label_encode:
  print(f'\ncolumn {cat} :')
  print(df4[cat].unique())
  print(df4[cat].value_counts())

# Grade
from sklearn.preprocessing import LabelEncoder

label_encoder = LabelEncoder()

df4['grade'] = label_encoder.fit_transform(df4['grade'])

# emp_length
emp_length_mapping = {
    '10+ years': 10,
    '< 1 year': 0,
    '1 year': 1,
    '2 years': 2,
    '3 years': 3,
    '4 years': 4,
    '5 years': 5,
    '6 years': 6,
    '7 years': 7,
    '8 years': 8,
    '9 years': 9
}

df4['emp_length'] = df4['emp_length'].map(emp_length_mapping)

df4.head()

"""#### One hot encoding"""

for cat in cats_one_hot:
  print(f'\ncolumn {cat} :')
  print(df4[cat].unique())
  print(df4[cat].value_counts())

df4['home_ownership'].value_counts()

print('test')

targetdict = {'OTHER':'OTHER',
               'ANY':'OTHER',
               'NONE':'OTHER',
               'MORTGAGE':'MORTGAGE',
               'RENT':'RENT',
               'OWN':'OWN',}

df4["home_ownership"] = df4["home_ownership"].map(targetdict)
df4['home_ownership'].value_counts()

for cat in cats_one_hot:
  print(f'\ncolumn {cat} :')
  print(df4[cat].unique())
  print(df4[cat].value_counts())

df4 = pd.get_dummies(df4, columns=cats_one_hot, prefix=['term', 'initial_status', 'ownership', 'purpose' ])
df4.head()

df4.info()

"""#### Numerical encoding

# Modeling
"""

df_model = df4.copy()

x = df_model.drop(['loan_status'], axis=1)
y = df_model['loan_status']

y.value_counts()

"""## Data Split"""

x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.3,random_state=24)
x_train.shape, x_test.shape, y_train.shape, y_test.shape

"""## Train Model"""

#model evaluation

def eval_classification(model):
    y_pred = model.predict(x_test)
    y_pred_train = model.predict(x_train)

    print("Accuracy (Test Set): %.2f" % accuracy_score(y_test, y_pred))
    print("Accuracy (Train set): %.2f" % accuracy_score(y_train, y_pred_train))
    print("\nPrecision (Test Set): %.2f" % precision_score(y_test, y_pred))
    print("Precision (Train Set): %.2f" % precision_score(y_train, y_pred_train))
    print("\nRecall (Test Set): %.2f" % recall_score(y_test, y_pred))
    print("Recall (Train Set): %.2f" % recall_score(y_train, y_pred_train))
    print("\nF1-Score (Test Set): %.2f" % f1_score(y_test, y_pred))
    print("F1-Score (Train Set): %.2f" % f1_score(y_train, y_pred_train))

def roc_auc_eval(model):
    y_pred_proba = model.predict_proba(x_test)
    y_pred_proba_train = model.predict_proba(x_train)

    print("\nroc_auc (test-proba): %.2f" % roc_auc_score(y_test, y_pred_proba[:, 1]))
    print("roc_auc (train-proba): %.2f" % roc_auc_score(y_train, y_pred_proba_train[:, 1]))

"""### Decision tree"""

dt = DecisionTreeClassifier()
dt.fit(x_train, y_train)

eval_classification(dt)
roc_auc_eval(dt)

"""### Hyperparameter tunning

### Decision tree random search
"""

param_grid = {
    'max_depth': [3, 5, 7],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'max_features': ['sqrt', 'log2', None]
}

grid_search = GridSearchCV(estimator=dt, param_grid=param_grid, cv=5, scoring='roc_auc')
grid_search.fit(x_train, y_train)

best_params = grid_search.best_params_
print("Best Hyperparameters:", best_params)

best_tree = DecisionTreeClassifier(**best_params)
best_tree.fit(x_train, y_train)
accuracy = best_tree.score(x_test, y_test)
print("Accuracy:", accuracy)

best_dt = grid_search.best_estimator_
best_params = grid_search.best_params_
best_score = grid_search.best_score_

print("Best Decision Tree Model:")
print(best_dt)
print("\nBest Parameters:")
print(best_params)
print("\nBest Recall Score:")
print(best_score)

"""### Retrain model"""

dt_model = best_dt.fit(x_train, y_train)

# Evaluasi model
eval_classification(dt_model)

roc_auc_eval(dt_model)

y_pred_proba = dt_model.predict_proba(x_test)[:, 1]

from sklearn.metrics import roc_curve, auc

fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', lw=2, label='ROC curve (AUC = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc='lower right')
plt.show()

y_pred = dt_model.predict(x_test)

conf_matrix = confusion_matrix(y_test, y_pred)
target_names = ['Bad Loan','Good Loan']

# Plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=target_names, yticklabels=target_names)
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

"""### Cross Validation"""

scores = cross_val_score(dt_model, x_train, y_train, cv=5, scoring='roc_auc')

# Print the cross-validation scores
print("Cross-validation scores:", scores)

# Calculate and print the mean score
print("Mean cross-validation score:", scores.mean())

"""### Feature Importance"""

importances = dt_model.feature_importances_


indices = np.argsort(importances)[::-1]


feature_names = x_train.columns

# Select top 10 most important features
top_n = 10
top_indices = indices[:top_n]

# top 10 feature ranking
print("Top 10 feature ranking:")
for f in range(top_n):
    print("%d. Feature '%s' (%f)" % (f + 1, feature_names[top_indices[f]], importances[top_indices[f]]))


plt.figure(figsize=(8, 6))
plt.title("Top 10 Feature Importances")
plt.barh(range(top_n), importances[top_indices][::-1], align="center", color = '#7752FE')
plt.yticks(range(top_n), feature_names[top_indices][::-1])
plt.xlabel("Importance")
plt.ylabel("Feature")
plt.tight_layout()
plt.show()

"""# Bussines Strategies

Based on feature importance :

1. **Last payment amount**
Increasing the payment amount taken from customers can reduce the chances of them becoming high-risk loans

2. **Loan amount**
The loan amount granted is linked to the associated interest rate to be paid. As the loan size increases, the corresponding interest rate also increases.

3. **Total Payment**
If payments fall within the range of 0 to 5000, it's probable that they would be deemed as problematic loans. This range often signals an increased likelihood of loan repayment issues or default.


4. **Payment Time**
The greater the duration customers have for repayment, the increased chance of them becoming high-risk loans.


5. **Interest Rate**
Higher interest rates taken by customers correlate with a rise in the rate of bad loans.  Consider to maintain low interest rate.
"""